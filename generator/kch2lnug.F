      SUBROUTINE KCH2LNUG(JKAON, PTYPE, LTYPE, MODE, PCHARGE)
C----------------------------------------------------------C
C K+- ->L NU GAMMA DECAY                                   C
C Sources: Bijnens, Ecker and Gasser, hep-ph/9209261;      C
C          Chen, Geng and Lih, arXiv:0710.2971.            C
C The "PDG definition" of the form factors is used:        C
C the form factors are defined as in arXiv:0710.2971,      C
C up to the sign of the interference term.                 C
C                                                          C
C LTYPE:  1=electron, 2=muon                               C
C MODE:   1=IB (E>10 MeV), 2=SD+, 3=SD-, 4=INT+, 5=INT-    C
C                                                          C
C The fully inclusive IB process (as in RK definition) is  C
C generated by a separate routine                          C 
C                                                          C
C Evgueni.Goudzovski@cern.ch                               C
C                                                          C
C 02/09/2007: original version                             C
C 13/02/2008: form-factor x-dependence introduced          C
C 25/02/2011: INT terms added                              C
C 03/02/2011: adapted for NA62MC                           C
C----------------------------------------------------------C
c
c     This version of the generator does not use GENBOD.
c     The variation of decay density over the phase space is
c     very large for some components, so a GENBOD-based generator is slow.
c     Moreover GENBOD eventually crashes after many calls.
c                                 -- E. Goudzovski, 10/04/2011
c

#include "common_blocks.f"
#include "masses.f"

      INTEGER PTYPE, LTYPE, MODE, PCHARGE

      INTEGER i, JLEP, JGAM, JNU, IDLEP, ffmode, IDNEUTRINO
      REAL*8 vec(3), P1(4,4), P2(4,4), P3(4,4), P4(4,4)
      REAL*8 PHI, SINPHI, COSPHI, COSTHE,SINTHE,COSPSI,SINPSI
      REAL*8 MPARENT, MLEP, Eg, Ee, Pe, En, Pgx, Pgy
      REAL*8 plep(4), pgam(4), pnu(4)
      REAL*8 x, y, ymin, rl, f1, f2, wtcomp, wtmax, ranf
      REAL*8 f_ib, f_sd_p, f_sd_m, f_int_p, f_int_m, f_here, Fa, Fv

      REAL*8 pi
      Parameter (pi = 3.141592653589793)

c ............................................

      if (mode.lt.1.or.mode.gt.5)    mode  = 1
      if (ptype.ne.1.and.ptype.ne.2) ptype = 1 ! parent type: kaon (1) or pion (2)
      if (ltype.ne.1.and.ltype.ne.2) ltype = 1 ! lepton type: electron (1) or muon (2)

      if (ptype.eq.1) MPARENT = MKCH
      if (ptype.eq.2) MPARENT = MPI
      if (ltype.eq.1) MLEP = MEL
      if (ltype.eq.2) MLEP = MMU
      rl = (MLEP/MPARENT)**2

      if (ptype.eq.1) then ! kaon decays

         if (ltype.eq.1.and.mode.eq.1) wtmax = 1e6    ! Ke2 IB, Eg > 10MeV
         if (ltype.eq.1.and.mode.eq.2) wtmax = 0.0028 ! Ke2 SD+
         if (ltype.eq.1.and.mode.eq.3) wtmax = 0.0006 ! Ke2 SD-
         if (ltype.eq.1.and.mode.eq.4) wtmax = 0.16   ! Ke2 INT+
         if (ltype.eq.1.and.mode.eq.5) wtmax = 17000. ! Ke2 INT-

         if (ltype.eq.2.and.mode.eq.1) wtmax = 5500.  ! Km2 IB, Eg > 10MeV
         if (ltype.eq.2.and.mode.eq.2) wtmax = 0.0025 ! Km2 SD+
         if (ltype.eq.2.and.mode.eq.3) wtmax = 0.0006 ! Km2 SD-
         if (ltype.eq.2.and.mode.eq.4) wtmax = 0.10   ! Km2 INT+
         if (ltype.eq.2.and.mode.eq.5) wtmax = 0.36   ! Km2 INT-

      else ! pion decays

         if (ltype.eq.1.and.mode.eq.1) wtmax = 1e6     ! pie2 IB, Eg > 10MeV
         if (ltype.eq.1.and.mode.eq.2) wtmax = 0.00021 ! pie2 SD+
         if (ltype.eq.1.and.mode.eq.3) wtmax = 0.00003 ! pie2 SD-
         if (ltype.eq.1.and.mode.eq.4) wtmax = 0.04    ! pie2 INT+
         if (ltype.eq.1.and.mode.eq.5) wtmax = 300.    ! pie2 INT-

         if (ltype.eq.2.and.mode.eq.1) wtmax = 1.8      ! pim2 IB, Eg > 10MeV
         if (ltype.eq.2.and.mode.eq.2) wtmax = 0.00002  ! pim2 SD+
         if (ltype.eq.2.and.mode.eq.3) wtmax = 0.000003 ! pim2 SD-
         if (ltype.eq.2.and.mode.eq.4) wtmax = 0.0025   ! pim2 INT+
         if (ltype.eq.2.and.mode.eq.5) wtmax = 0.0015   ! pim2 INT-

      endif

c ... Notes for kaon decays:
c ...    (1) INT- is negative (destructive interference); the opposite is simulated;
c ...    (2) INT+- densities change sign over the Dalitz plot for the LFQM form factor
c ...        for both Ke2g and Kmu2g decays, making this approach to event generation
c ...        invalid for INT+- modes with LQFM form factors.

c ... Generate (x,y) uniformly over the Kl2g Dalitz plot

 1    CONTINUE
      x    = ranf() * (1-rl)
      y    = ranf() * (1+rl)
      ymin = 1.0-x+rl/(1.0-x)
      if (y.lt.ymin) goto 1

c ... Infrared cut-off for the IB modes.
c ... NB: collinear cut-off needs to be added to Ke2g (IB).
      if (mode.eq.1) then
        Eg = 0.5 * MPARENT * x
        if (Eg.lt.0.010) goto 1
      endif

      if (ptype.eq.1) then ! kaon

C  ------ FORM-FACTORS OF KAON TRANSITIONS -----
C
C  Form-factors for SD modes are implemented following Chen,Geng,Lih,arXiv:0710.2971
C  Three models exist: ChPT O(p^4), ChPT O(p^6), LFQM [see paper for details]
C  The original codes to compute the form-factors were provided by C.Q.Geng.
C  Switching between the three models is done via the hardcoded ffmode key below.
C  The LFQM form-factors were pre-tabulated and approximated by polynomials,
C  since the online computation is too heavy.
C  BR(Kl2g)/BR(Kl2 tree level) predicted by each of the models are
C  0.803,0.692,0.609 (Ke2 SD+), 0.116,0.153,0.145 (Ke2 SD-),
C  1.46,1.29,1.01*10^{-5} (Kmu2 SD+), 2.11,2.93,2.38*10^{-6} (Kmu2 SD-).
C  For BRs in the O(p4) model, see Table 4 of Bijnens, Ecker & Gasser, hep-ph/9209261.
C
C                                             -- E. Goudzovski, 13/02/2008

         ffmode = 4 ! one can change the form factor model (see below: 1-4)

         if (ffmode.eq.1) then ! ChPT O(p^4)
            Fa = 0.0425
            Fv = 0.0945
         endif

         if (ffmode.eq.2) then ! ChPT O(p^6)
            Fa = 0.034 - 0.003673469*SQMKCH*(1.0-x)
            Fv = 0.082 + 0.138775500*SQMKCH*(1.0-x)
         endif

         if (ffmode.eq.3) then ! LFQM
            if (x.lt.0.08) then
               Fa =
     >              -1.356327e-05 +5.997996e-03*x -5.337975e-01*x**2
     >              +1.132491e+01*x**3 -5.258472e+01*x**4
            endif
            if (x.ge.0.08.and.x.le.0.86) then
               Fa =
     >              -7.250467e-04 -5.931204e-03*x +3.558682e-01*x**2
     >              -9.405042e-01*x**3 +1.330232e+00*x**4
     >              -1.003100e+00*x**5 +2.984260e-01*x**6
            endif
            if (x.gt.0.86) then
               Fa =
     >              +3.907690e+01 -1.627609e+02*x +1.900648e+02*x**2
     >              +9.243691e+01*x**3 -3.759822e+02*x**4
     >              +2.939501e+02*x**5 -7.675012e+01*x**6
            endif
            Fv =
     >           -9.841496e-05 -2.672904e-02*x +2.313763e+00*x**2
     >           -1.371653e+01*x**3 +4.509183e+01*x**4
     >           -8.960486e+01*x**5 +1.092287e+02*x**6
     >           -7.927143e+01*x**7 +3.123944e+01*x**8
     >           -5.150555e+00*x**9
         endif

         if (ffmode.eq.4) then  ! ChPT O(p^6), Fa and Fv as measured by KLOE, arXiv:0907.3594
            Fa = 0.0365
            Fv = 0.0885 * (1.0 + 0.38*(1.0-x))
         endif
      endif

c ... Pion decays: constant FF are simulated following PDG 2016.
c ... According to PDG 2016, there is no evidence for kinematic dependence.

      if (ptype.eq.2) then ! pion
         Fa = 0.0119
         Fv = 0.0254
      endif

c  ------  MATRIX ELEMENT  ------
      f1      = 1.0-y+rl
      f2      = x+y-1.0-rl
      f_ib    = f1/(x*x*f2)*(x*x+2.*(1.-x)*(1.-rl)-2.*x*rl*(1.-rl)/f2)
      f_sd_p  = (Fv+Fa)**2 * f2 * ((x+y-1)*(1-x)-rl)
      f_sd_m  = (Fv-Fa)**2 * (1.0-y+rl) * ((1-x)*(1-y)+rl)
      f_int_p = -(Fv+Fa)*f1/x/f2*((1.-x)*(1.-x-y)+rl)
      f_int_m = -(Fv-Fa)*f1/x/f2*(x*x-(1.-x)*(1.-x-y)-rl)

      if (mode.eq.1) f_here =  f_ib
      if (mode.eq.2) f_here =  f_sd_p
      if (mode.eq.3) f_here =  f_sd_m
      if (mode.eq.4) f_here =  f_int_p
      if (mode.eq.5) f_here = -f_int_m  ! inverted sign makes it positive

      wtcomp = ranf()*wtmax
      if (wtcomp.gt.f_here) goto 1

c --- Trasform (x,y) into 4-momenta in kaon rest frame
c ... Lepton momentum is aligned along the X axis
      Eg  = 0.5 * MPARENT * X
      Ee  = 0.5 * MPARENT * Y
      En  = MPARENT - Eg - Ee
      Pe  = sqrt(Ee**2 - MLEP**2)
      Pgx = 0.5 * (En**2 - Eg**2 - Pe**2) / Pe
      Pgy = sqrt(Eg**2 - Pgx**2)

      plep(1) = Pe
      plep(2) = 0.0
      plep(3) = 0.0
      plep(4) = Ee
      pgam(1) = Pgx
      pgam(2) = Pgy
      pgam(3) = 0.0
      pgam(4) = Eg
      pnu(1)  = -Pe-Pgx
      pnu(2)  = -Pgy
      pnu(3)  = 0.0
      pnu(4)  = En

c --- Finally, perform a rotation

c --- For rotation of momenta into a random direction, let us use
c --- the Euler angles: rotations around z, unrotated x, unrotated z

      DO I = 1, 4
         P1(1, I) = Plep(I)
         P1(2, I) = Pgam(I)
         P1(3, I) = Pnu(I)
      ENDDO

c --- a) Counterclockwise rotation around Z axis (PHI)
      PHI    = RANF()*2.0*PI
      SINPHI = DSIN(PHI)
      COSPHI = DCOS(PHI)
      DO I = 1, 3
         P2(I,1) =  P1(I,1)*COSPHI + P1(I,2)*SINPHI
         P2(I,2) = -P1(I,1)*SINPHI + P1(I,2)*COSPHI
         P2(I,3) =  P1(I,3)
         P2(I,4) =  P1(I,4)
      ENDDO

c --- b) Generate uniformly the new direction of Z axis,
c ---    define the corresponding Euler angles THETA, PSI
      CALL GENSPH(VEC)
      COSTHE = VEC(3)/SQRT(VEC(1)**2+VEC(2)**2+VEC(3)**2)
      SINTHE = SQRT((VEC(1)**2+VEC(2)**2)/
     >              (VEC(1)**2+VEC(2)**2+VEC(3)**2))
      COSPSI = VEC(2)/SQRT(VEC(1)**2+VEC(2)**2)
      SINPSI = VEC(1)/SQRT(VEC(1)**2+VEC(2)**2)

c --- c) Clockwise rotation around X axis (THETA)
      DO I = 1, 3
         P3(I,1) = P2(I,1)
         P3(I,2) = P2(I,2)*COSTHE - P2(I,3)*SINTHE
         P3(I,3) = P2(I,2)*SINTHE + P2(I,3)*COSTHE
         P3(I,4) = P2(I,4)
      ENDDO

c --- d) Counterclockwise rotation around Z axis (PSI)
      DO I = 1, 3
         P4(I,1) = P3(I,1)*COSPSI - P3(I,2)*SINPSI
         P4(I,2) = P3(I,1)*SINPSI + P3(I,2)*COSPSI
         P4(I,3) = P3(I,3)
         P4(I,4) = P3(I,4)
      ENDDO

c --- put the results back into the original vectors
      do i = 1, 4
         Plep(i) = P4(1, I)
         Pgam(i) = P4(2, I)
         Pnu(i)  = P4(3, I)
      enddo

c-------------------------------------------------------

c --- FILL MC PARTICLE LIST
      if (pcharge.eq.1.and.ltype.eq.1) then 
        IDLEP = IDELEP
        IDNEUTRINO = IDNUE
      endif
      if (pcharge.eq.1.and.ltype.eq.2) then 
        IDLEP = IDMUP
        IDNEUTRINO = IDNUM
      endif
      if (pcharge.eq.-1.and.ltype.eq.1) then
        IDLEP = IDELEM
        IDNEUTRINO = IDNUE
      endif
      if (pcharge.eq.-1.and.ltype.eq.2) then
        IDLEP = IDMUM
        IDNEUTRINO = IDNUM
      endif
      if (MainDecay.eq.1) then
        if (ptype.eq.1) then
          JLEP = MCADD4GEN(IDLEP, plep, 0)
          JNU  = MCADD4GEN(IDNEUTRINO,  pnu,  0)
          JGAM = MCADD4GEN(IDGAM, pgam, 0)
        else
          JLEP = MCADD4GEN(IDLEP, plep, 4)
          JNU  = MCADD4GEN(IDNEUTRINO,  pnu,  4)
          JGAM = MCADD4GEN(IDGAM, pgam, 4)
        endif
      endif

c --- BOOST TO THE LAB-SYSTEM
      CALL DBOOST(P4INI(1,JKAON),MPARENT,plep,plep)
      CALL DBOOST(P4INI(1,JKAON),MPARENT,pnu, pnu )
      CALL DBOOST(P4INI(1,JKAON),MPARENT,pgam,pgam)

c --- FILL MC PARTICLE LIST
      JLEP = MCADD4(IDLEP, plep)
      JNU  = MCADD4(IDNEUTRINO,  pnu)
      JGAM = MCADD4(IDGAM, pgam)

      RETURN
      END
